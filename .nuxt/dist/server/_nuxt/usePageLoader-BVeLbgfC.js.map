{"version":3,"file":"usePageLoader-BVeLbgfC.js","sources":["../../../../node_modules/nuxt/dist/app/components/server-placeholder.js","../../../../node_modules/nuxt/dist/app/components/client-only.js","../../../../components/pageHeader/MainNav.vue","../../../../composables/usePageLoader.js"],"sourcesContent":["import { createElementBlock, defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"ServerPlaceholder\",\n  render() {\n    return createElementBlock(\"div\");\n  }\n});\n","import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, ref } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nimport { elToStaticVNode } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nconst STATIC_DIV = \"<div></div>\";\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  setup(_, { slots, attrs }) {\n    const mounted = ref(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    const vm = getCurrentInstance();\n    if (vm) {\n      vm._nuxtClientOnly = true;\n    }\n    provide(clientOnlySymbol, true);\n    return (props) => {\n      if (mounted.value) {\n        return slots.default?.();\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return slot();\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      }\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\n    };\n  } else {\n    clone.template &&= `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else>${STATIC_DIV}</template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = ref(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 ||= {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            return h(setupState(...args), ctx.attrs);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","<template>\r\n  <nav class=\"navbar navbar-expand-lg navbar-light bg-light\" :class=\"{ 'fixed-top': isScrolled, 'navbar-shadow': isScrolled }\">\r\n    <div class=\"container\">\r\n      <!-- Logo -->\r\n      <NuxtLink class=\"navbar-brand\" to=\"/\">\r\n        <img :src=\"navbar.logoSrc\" :alt=\"navbar.logoAlt\" height=\"40\" />\r\n      </NuxtLink>\r\n\r\n      <!-- Toggler -->\r\n      <button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"offcanvas\" data-bs-target=\"#offcanvasNavbar\"\r\n              aria-controls=\"offcanvasNavbar\" aria-label=\"Toggle navigation\">\r\n        <span class=\"navbar-toggler-icon\"></span>\r\n      </button>\r\n\r\n      <!-- Offcanvas Menu (Mobile) -->\r\n      <div class=\"offcanvas offcanvas-end custom-offcanvas d-lg-none\" id=\"offcanvasNavbar\">\r\n        <div class=\"offcanvas-header\">\r\n          <h5 class=\"offcanvas-title\">{{ navbar.offcanvasTitle }}</h5>\r\n          <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"offcanvas\"></button>\r\n        </div>\r\n        <div class=\"offcanvas-body\">\r\n          <ul class=\"navbar-nav justify-content-end flex-grow-1 pe-3\">\r\n            <li v-for=\"(item, index) in navbar.navLinks\" :key=\"index\" class=\"nav-item\">\r\n              <NuxtLink class=\"nav-link\" :to=\"item.link\" :class=\"{ active: isActive(item.link) }\"\r\n                        @click=\"handleNav(item.link)\">\r\n                {{ item.text }}\r\n              </NuxtLink>\r\n            </li>\r\n          </ul>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Desktop Menu -->\r\n      <div class=\"collapse navbar-collapse d-none d-lg-flex justify-content-end\" id=\"navbarNav\">\r\n        <ul class=\"navbar-nav\">\r\n          <li v-for=\"(item, index) in navbar.navLinks\" :key=\"index\" class=\"nav-item\">\r\n            <NuxtLink class=\"nav-link\" :to=\"item.link\" :class=\"{ active: isActive(item.link) }\"\r\n                      @click=\"handleNav(item.link)\">\r\n              {{ item.text }}\r\n            </NuxtLink>\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n  </nav>\r\n</template>\r\n\r\n<script setup>\r\nimport { ref, onMounted, onBeforeUnmount } from 'vue'\r\nimport { useRoute, navigateTo } from '#app'\r\n\r\nconst navbar = ref({\r\n  logoSrc: '',\r\n  logoAlt: '',\r\n  offcanvasTitle: '',\r\n  navLinks: []\r\n})\r\n\r\nconst isScrolled = ref(false)\r\nconst route = useRoute()\r\n\r\nasync function loadContentFromTxt() {\r\n  const res = await fetch('/data/navBar.txt')\r\n  const content = await res.text()\r\n  const lines = content.split('\\n')\r\n\r\n  lines.forEach(line => {\r\n    const [key, value] = line.split('=')\r\n    if (!key || !value) return\r\n\r\n    const trimmedKey = key.trim()\r\n    const trimmedValue = value.trim()\r\n\r\n    switch (trimmedKey) {\r\n      case 'navbarLogoSrc':\r\n        navbar.value.logoSrc = trimmedValue\r\n        break\r\n      case 'navbarLogoAlt':\r\n        navbar.value.logoAlt = trimmedValue\r\n        break\r\n      case 'navbarOffcanvasTitle':\r\n        navbar.value.offcanvasTitle = trimmedValue\r\n        break\r\n      case 'navbarLinks':\r\n        navbar.value.navLinks = trimmedValue.split(',').map(pair => {\r\n          const [text, link] = pair.split('|')\r\n          return { text: text.trim(), link: link.trim() }\r\n        })\r\n        break\r\n    }\r\n  })\r\n}\r\n\r\nfunction handleNav(link) {\r\n  if (link.startsWith('#')) {\r\n    const target = document.querySelector(link)\r\n    if (target) {\r\n      const offset = -70\r\n      const top = target.getBoundingClientRect().top + window.scrollY + offset\r\n      window.scrollTo({ top, behavior: 'smooth' })\r\n    }\r\n  } else {\r\n    navigateTo(link)\r\n  }\r\n\r\n  const offcanvas = document.getElementById('offcanvasNavbar')\r\n  if (offcanvas?.classList.contains('show')) {\r\n    bootstrap.Offcanvas.getInstance(offcanvas)?.hide()\r\n  }\r\n}\r\n\r\nfunction isActive(link) {\r\n  return route.path === link || (link.startsWith('#') && route.hash === link)\r\n}\r\n\r\nfunction handleScroll() {\r\n  isScrolled.value = window.scrollY > 50\r\n}\r\n\r\nonMounted(() => {\r\n  loadContentFromTxt()\r\n  if (process.client) window.addEventListener('scroll', handleScroll)\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  if (process.client) window.removeEventListener('scroll', handleScroll)\r\n})\r\n</script>\r\n\r\n<style scoped>\r\n@media (max-width: 991px) {\r\n  .custom-offcanvas {\r\n    width: 50%;\r\n  }\r\n}\r\n</style>\r\n","// composables/usePageLoader.js\r\nimport { ref, onMounted, nextTick } from 'vue'\r\n\r\nexport function usePageLoader(delay = 300) {\r\n  const loading = ref(true)\r\n\r\n  async function waitForAllImages() {\r\n    const images = Array.from(document.images)\r\n    const unloaded = images.filter(img => !img.complete)\r\n\r\n    if (!unloaded.length) return Promise.resolve()\r\n\r\n    return Promise.all(\r\n      unloaded.map(\r\n        img =>\r\n          new Promise(resolve => {\r\n            img.onload = img.onerror = resolve\r\n          })\r\n      )\r\n    )\r\n  }\r\n\r\n  onMounted(async () => {\r\n    await nextTick()\r\n    await waitForAllImages()\r\n    setTimeout(() => {\r\n      loading.value = false\r\n    }, delay)\r\n  })\r\n\r\n  return { loading }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,SAAS;AACP,WAAO,mBAAmB,KAAK;AAAA,EACnC;AACA,CAAC;ACDM,MAAM,mBAAmB,OAAO,IAAI,kBAAkB;AAE9C,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO,CAAC,YAAY,eAAe,kBAAkB,aAAa;AAAA,EAClE,MAAM,GAAG,EAAE,OAAO,MAAK,GAAI;AACzB,UAAM,UAAU,IAAI,KAAK;AASzB,UAAM,KAAK,mBAAoB;AAC/B,QAAI,IAAI;AACN,SAAG,kBAAkB;AAAA,IAC3B;AACI,YAAQ,kBAAkB,IAAI;AAC9B,WAAO,CAAC,UAAU;;AAChB,UAAI,QAAQ,OAAO;AACjB,gBAAO,WAAM,YAAN;AAAA,MACf;AACM,YAAM,OAAO,MAAM,YAAY,MAAM;AACrC,UAAI,MAAM;AACR,eAAO,KAAM;AAAA,MACrB;AACM,YAAM,cAAc,MAAM,YAAY,MAAM,eAAe;AAC3D,YAAM,cAAc,MAAM,eAAe,MAAM,kBAAkB;AACjE,aAAO,mBAAmB,aAAa,OAAO,WAAW;AAAA,IAC1D;AAAA,EACL;AACA,CAAC;;;;;ACYD,UAAM,SAAS,IAAI;AAAA,MACjB,SAAS;AAAA,MACT,SAAS;AAAA,MACT,gBAAgB;AAAA,MAChB,UAAU,CAAA;AAAA,IAAC,CACZ;AAEK,UAAA,aAAa,IAAI,KAAK;AAC5B,UAAM,QAAQ,SAAS;AAkCvB,aAAS,UAAU,MAAM;;AACnB,UAAA,KAAK,WAAW,GAAG,GAAG;AAClB,cAAA,SAAkB,SAAA,cAAc,IAAI;AAC1C,YAAI,QAAQ;AACV,gBAAM,SAAS;AACf,gBAAM,MAAM,OAAO,sBAAA,EAAwB,eAAa,UAAU;AAClE,UAAA,SAAO,SAAS,EAAE,KAAK,UAAU,UAAU;AAAA,QAAA;AAAA,MAC7C,OACK;AACL,mBAAW,IAAI;AAAA,MAAA;AAGX,YAAA,YAAqB,SAAA,eAAe,iBAAiB;AAC3D,UAAI,uCAAW,UAAU,SAAS,SAAS;AACzC,wBAAU,UAAU,YAAY,SAAS,MAAzC,mBAA4C;AAAA,MAAK;AAAA,IACnD;AAGF,aAAS,SAAS,MAAM;AACf,aAAA,MAAM,SAAS,QAAS,KAAK,WAAW,GAAG,KAAK,MAAM,SAAS;AAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GxD,SAAA,cAAc,QAAQ,KAAK;AACnC,QAAA,UAAU,IAAI,IAAI;AA0BxB,SAAO,EAAE,QAAQ;AACnB;","x_google_ignoreList":[0,1]}